/***
 Automatic generated by gen-opcodetable.bash
***/
#include "decode.h"
//#include "opcode_tbl.h"
#include "mu-code.h"
struct opcode_entry opcode_tbl[256] = {
{ 0x00 , "BRK", "imp", 1 , 0 , cpu_6502_BRK_imp, "BRK ", "implizit; no additional info needed", "--1-1--", " interrupt ", " (S)-=:PC,P PC:=($FFFE) ", imp_adr_mode, "    PC = PC + 1 \n    bPoke(SP,PC.h) \n    SP = SP - 1 \n    bPoke(SP,PC.l) \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x01 , "ORA", "izx", 2 , 6 , cpu_6502_ORA_izx, "ORA ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " or with accumulator ", " A:=A or {adr} ", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x02 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x03 , " *SLO ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x04 , " *NOP ", "zp", 2 , 3 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x05 , "ORA", "zp", 2 , 3 , cpu_6502_ORA_zp, "ORA $AB", "zero page ; ea = zpadr", "*----*-", " or with accumulator ", " A:=A or {adr} ", zp_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x06 , "ASL", "zp", 2 , 5 , cpu_6502_ASL_zp, "ASL $AB", "zero page ; ea = zpadr", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", zp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x07 , " *SLO ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x08 , "PHP", "imp", 1 , 3 , cpu_6502_PHP_imp, "PHP ", "implizit; no additional info needed", "-------", " push processor status (SR) ", " (S)-:=P ", imp_adr_mode, "    bPoke(SP,P) \n    SP = SP - 1  \n \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x09 , "ORA", "imm", 2 , 2 , cpu_6502_ORA_imm, "ORA #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " or with accumulator ", " A:=A or {adr} ", imm_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0A , "ASL", "imp", 1 , 2 , cpu_6502_ASL_imp, "ASL ", "implizit; no additional info needed", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", imp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0B , " *ANC ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0C , " *NOP ", "abs", 3 , 4 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0D , "ORA", "abs", 3 , 4 , cpu_6502_ORA_abs, "ORA $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " or with accumulator ", " A:=A or {adr} ", abs_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0E , "ASL", "abs", 3 , 6 , cpu_6502_ASL_abs, "ASL $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", abs_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0F , " *SLO ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x10 , "BPL", "rel", 2 , 3 , cpu_6502_BPL_rel, "BPL $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on plus (negative clear) ", " branch on N=0 ", rel_adr_mode, "    if (P.N == 0) GOTO (PC+M)  \n \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x11 , "ORA", "izy", 2 , 5 , cpu_6502_ORA_izy, "ORA ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " or with accumulator ", " A:=A or {adr} ", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x12 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x13 , " *SLO ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x14 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x15 , "ORA", "zpx", 2 , 4 , cpu_6502_ORA_zpx, "ORA $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " or with accumulator ", " A:=A or {adr} ", zpx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x16 , "ASL", "zpx", 2 , 6 , cpu_6502_ASL_zpx, "ASL $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", zpx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x17 , " *SLO ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x18 , "CLC", "imp", 1 , 2 , cpu_6502_CLC_imp, "CLC ", "implizit; no additional info needed", "------0", " clear carry ", " C:=0 ", imp_adr_mode, "    P.C = 0  \n \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x19 , "ORA", "aby", 3 , 4 , cpu_6502_ORA_aby, "ORA $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " or with accumulator ", " A:=A or {adr} ", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1A , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1B , " *SLO ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1C , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1D , "ORA", "abx", 3 , 4 , cpu_6502_ORA_abx, "ORA $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " or with accumulator ", " A:=A or {adr} ", abx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1E , "ASL", "abx", 3 , 7 , cpu_6502_ASL_abx, "ASL $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", abx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1F , " *SLO ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x20 , "JSR", "abs", 3 , 6 , cpu_6502_JSR_abs, "JSR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " jump subroutine ", " (S)-:=PC PC:={adr} ", abs_adr_mode, "    t = PC - 1 \n    bPoke(SP,t.h) \n    SP = SP - 1 \n    bPoke(SP,t.l) \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x21 , "AND", "izx", 2 , 6 , cpu_6502_AND_izx, "AND ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", izx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x22 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x23 , " *RLA ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x24 , "BIT", "zp", 2 , 3 , cpu_6502_BIT_zp, "BIT $AB", "zero page ; ea = zpadr", "**---*-", " bit test ", " N:=b7 V:=b6 Z:=A&{adr} ", zp_adr_mode, "    t = A & M \n    P.N = t.7 \n    P.V = t.6 \n    P.Z = (t==0) ? 1:0  \n \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x25 , "AND", "zp", 2 , 3 , cpu_6502_AND_zp, "AND $AB", "zero page ; ea = zpadr", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", zp_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x26 , "ROL", "zp", 2 , 5 , cpu_6502_ROL_zp, "ROL $AB", "zero page ; ea = zpadr", "*----**", " rotate left ", " {adr}:={adr}*2+C ", zp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x27 , " *RLA ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x28 , "PLP", "imp", 1 , 4 , cpu_6502_PLP_imp, "PLP ", "implizit; no additional info needed", "**-****", " pull processor status (SR) ", " P:=+(S) ", imp_adr_mode, "    SP = SP + 1 \n    P = bPeek(SP)   \n \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x29 , "AND", "imm", 2 , 2 , cpu_6502_AND_imm, "AND #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", imm_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2A , "ROL", "imp", 1 , 2 , cpu_6502_ROL_imp, "ROL ", "implizit; no additional info needed", "*----**", " rotate left ", " {adr}:={adr}*2+C ", imp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2B , " *ANC ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2C , "BIT", "abs", 3 , 4 , cpu_6502_BIT_abs, "BIT $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "**---*-", " bit test ", " N:=b7 V:=b6 Z:=A&{adr} ", abs_adr_mode, "    t = A & M \n    P.N = t.7 \n    P.V = t.6 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2D , "AND", "abs", 3 , 4 , cpu_6502_AND_abs, "AND $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", abs_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2E , "ROL", "abs", 3 , 6 , cpu_6502_ROL_abs, "ROL $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " rotate left ", " {adr}:={adr}*2+C ", abs_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2F , " *RLA ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x30 , "BMI", "rel", 2 , 2 , cpu_6502_BMI_rel, "BMI $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on minus (negative set) ", " branch on N=1 ", rel_adr_mode, "    if (P.N == 1) GOTO (PC+M)  \n \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x31 , "AND", "izy", 2 , 5 , cpu_6502_AND_izy, "AND ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x32 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x33 , " *RLA ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x34 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x35 , "AND", "zpx", 2 , 4 , cpu_6502_AND_zpx, "AND $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", zpx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x36 , "ROL", "zpx", 2 , 6 , cpu_6502_ROL_zpx, "ROL $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " rotate left ", " {adr}:={adr}*2+C ", zpx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x37 , " *RLA ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x38 , "SEC", "imp", 1 , 2 , cpu_6502_SEC_imp, "SEC ", "implizit; no additional info needed", "------1", " set carry ", " C:=1 ", imp_adr_mode, "    P.C = 1  \n \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x39 , "AND", "aby", 3 , 4 , cpu_6502_AND_aby, "AND $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3A , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3B , " *RLA ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3C , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3D , "AND", "abx", 3 , 4 , cpu_6502_AND_abx, "AND $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", abx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3E , "ROL", "abx", 3 , 7 , cpu_6502_ROL_abx, "ROL $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " rotate left ", " {adr}:={adr}*2+C ", abx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3F , " *RLA ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x40 , "RTI", "imp", 1 , 6 , cpu_6502_RTI_imp, "RTI ", "implizit; no additional info needed", "**-****", " return from interrupt ", " P,PC:=+(S) ", imp_adr_mode, "    SP = SP - 1 \n    P = bPeek(SP) \n    SP = SP - 1 \n    l = bPeek(SP) \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x41 , "EOR", "izx", 2 , 6 , cpu_6502_EOR_izx, "EOR ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x42 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x43 , " *SRE ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x44 , " *NOP ", "zp", 2 , 3 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x45 , "EOR", "zp", 2 , 3 , cpu_6502_EOR_zp, "EOR $AB", "zero page ; ea = zpadr", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", zp_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x46 , "LSR", "zp", 2 , 5 , cpu_6502_LSR_zp, "LSR $AB", "zero page ; ea = zpadr", "*----**", " logical shift right ", " {adr}:={adr}/2 ", zp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x47 , " *SRE ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x48 , "PHA", "imp", 1 , 3 , cpu_6502_PHA_imp, "PHA ", "implizit; no additional info needed", "-------", " push accumulator ", " (S)-:=A ", imp_adr_mode, "    bPoke(SP,A) \n    SP = SP - 1  \n \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x49 , "EOR", "imm", 2 , 2 , cpu_6502_EOR_imm, "EOR #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", imm_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4A , "LSR", "imp", 1 , 2 , cpu_6502_LSR_imp, "LSR ", "implizit; no additional info needed", "*----**", " logical shift right ", " {adr}:={adr}/2 ", imp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4B , " *ALR ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4C , "JMP", "abs", 3 , 3 , cpu_6502_JMP_abs, "JMP $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " jump ", " PC:={adr} ", abs_adr_mode, "    PC = M  \n \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4D , "EOR", "abs", 3 , 4 , cpu_6502_EOR_abs, "EOR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", abs_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4E , "LSR", "abs", 3 , 6 , cpu_6502_LSR_abs, "LSR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " logical shift right ", " {adr}:={adr}/2 ", abs_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4F , " *SRE ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x50 , "BVC", "rel", 2 , 3 , cpu_6502_BVC_rel, "BVC $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on overflow clear ", " branch on V=0 ", rel_adr_mode, "    if (P.V == 0) GOTO (PC+M)  \n \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x51 , "EOR", "izy", 2 , 5 , cpu_6502_EOR_izy, "EOR ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x52 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x53 , " *SRE ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x54 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x55 , "EOR", "zpx", 2 , 4 , cpu_6502_EOR_zpx, "EOR $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", zpx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x56 , "LSR", "zpx", 2 , 6 , cpu_6502_LSR_zpx, "LSR $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " logical shift right ", " {adr}:={adr}/2 ", zpx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x57 , " *SRE ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x58 , "CLI", "imp", 1 , 2 , cpu_6502_CLI_imp, "CLI ", "implizit; no additional info needed", "----0--", " clear interrupt disable ", " I:=0 ", imp_adr_mode, "    P.I = 0  \n \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x59 , "EOR", "aby", 3 , 4 , cpu_6502_EOR_aby, "EOR $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5A , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5B , " *SRE ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5C , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5D , "EOR", "abx", 3 , 4 , cpu_6502_EOR_abx, "EOR $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", abx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5E , "LSR", "abx", 3 , 7 , cpu_6502_LSR_abx, "LSR $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " logical shift right ", " {adr}:={adr}/2 ", abx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5F , " *SRE ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x60 , "RTS", "imp", 1 , 6 , cpu_6502_RTS_imp, "RTS ", "implizit; no additional info needed", "-------", " return from subroutine ", " PC:=+(S) ", imp_adr_mode, "    SP = SP + 1 \n    l = bPeek(SP) \n    SP = SP + 1 \n    h = bPeek(SP)<<8 \n    PC = (h|l) +1     \n \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x61 , "ADC", "izx", 2 , 6 , cpu_6502_ADC_izx, "ADC ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", " add with carry ", " A:=A+{adr} ", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x62 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x63 , " *RRA ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x64 , " *NOP ", "zp", 2 , 3 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x65 , "ADC", "zp", 2 , 3 , cpu_6502_ADC_zp, "ADC $AB", "zero page ; ea = zpadr", "**---**", " add with carry ", " A:=A+{adr} ", zp_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
{ 0x66 , "ROR", "zp", 2 , 5 , cpu_6502_ROR_zp, "ROR $AB", "zero page ; ea = zpadr", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", zp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
{ 0x67 , " *RRA ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
{ 0x68 , "PLA", "imp", 1 , 4 , cpu_6502_PLA_imp, "PLA ", "implizit; no additional info needed", "*----*-", " pull accumulator ", " A:=+(S) ", imp_adr_mode, "    SP = SP + 1 \n    A = bPeek(SP) \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
{ 0x69 , "ADC", "imm", 2 , 2 , cpu_6502_ADC_imm, "ADC #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "**---**", " add with carry ", " A:=A+{adr} ", imm_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6A , "ROR", "imp", 1 , 2 , cpu_6502_ROR_imp, "ROR ", "implizit; no additional info needed", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", imp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6B , " *ARR ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6C , "JMP", "ind", 3 , 5 , cpu_6502_JMP_ind, "JMP $ABCD", "indirect; indirection via zp address; ea = mem[zpadr+1]|mem[zpadr]", "-------", " jump ", " PC:={adr} ", ind_adr_mode, "    PC = M  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6D , "ADC", "abs", 3 , 4 , cpu_6502_ADC_abs, "ADC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "**---**", " add with carry ", " A:=A+{adr} ", abs_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6E , "ROR", "abs", 3 , 6 , cpu_6502_ROR_abs, "ROR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", abs_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6F , " *RRA ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x70 , "BVS", "rel", 2 , 2 , cpu_6502_BVS_rel, "BVS $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on overflow set ", " branch on V=1 ", rel_adr_mode, "    if (P.V == 1) GOTO (PC+M)  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x71 , "ADC", "izy", 2 , 5 , cpu_6502_ADC_izy, "ADC ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", " add with carry ", " A:=A+{adr} ", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x72 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x73 , " *RRA ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x74 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x75 , "ADC", "zpx", 2 , 4 , cpu_6502_ADC_zpx, "ADC $AB,X", "zero page with index register X; ea = zpadr+X", "**---**", " add with carry ", " A:=A+{adr} ", zpx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x76 , "ROR", "zpx", 2 , 6 , cpu_6502_ROR_zpx, "ROR $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", zpx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x77 , " *RRA ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x78 , "SEI", "imp", 1 , 2 , cpu_6502_SEI_imp, "SEI ", "implizit; no additional info needed", "----1--", " set interrupt disable ", " I:=1 ", imp_adr_mode, "    P.I = 1  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x79 , "ADC", "aby", 3 , 4 , cpu_6502_ADC_aby, "ADC $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", " add with carry ", " A:=A+{adr} ", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7A , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7B , " *RRA ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7C , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7D , "ADC", "abx", 3 , 4 , cpu_6502_ADC_abx, "ADC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "**---**", " add with carry ", " A:=A+{adr} ", abx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7E , "ROR", "abx", 3 , 7 , cpu_6502_ROR_abx, "ROR $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", abx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7F , " *RRA ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x80 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x81 , "STA", "izx", 2 , 6 , cpu_6502_STA_izx, "STA ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "-------", " store accumulator ", " {adr}:=A ", izx_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x82 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "-------", "", "", izx_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x83 , " *SAX ", "izx", 2 , 6 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "-------", "", "", izx_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x84 , "STY", "zp", 2 , 3 , cpu_6502_STY_zp, "STY $AB", "zero page ; ea = zpadr", "-------", " store Y ", " {adr}:=Y ", zp_adr_mode, "    M = Y   \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x85 , "STA", "zp", 2 , 3 , cpu_6502_STA_zp, "STA $AB", "zero page ; ea = zpadr", "-------", " store accumulator ", " {adr}:=A ", zp_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x86 , "STX", "zp", 2 , 3 , cpu_6502_STX_zp, "STX $AB", "zero page ; ea = zpadr", "-------", " store X ", " {adr}:=X ", zp_adr_mode, "    M = X   \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x87 , " *SAX ", "zp", 2 , 3 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "-------", "", "", zp_adr_mode, "    M = X   \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x88 , "DEY", "imp", 1 , 2 , cpu_6502_DEY_imp, "DEY ", "implizit; no additional info needed", "*----*-", " decrement Y ", " Y:=Y-1 ", imp_adr_mode, "    Y = Y - 1 \n    P.Z = (Y==0) ? 1:0 \n    P.N = Y.7           \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x89 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    Y = Y - 1 \n    P.Z = (Y==0) ? 1:0 \n    P.N = Y.7           \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8A , "TXA", "imp", 1 , 2 , cpu_6502_TXA_imp, "TXA ", "implizit; no additional info needed", "*----*-", " transfer X to accumulator ", " A:=X ", imp_adr_mode, "    A = X \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8B , " *XAA ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    A = X \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8C , "STY", "abs", 3 , 4 , cpu_6502_STY_abs, "STY $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " store Y ", " {adr}:=Y ", abs_adr_mode, "    M = Y   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8D , "STA", "abs", 3 , 4 , cpu_6502_STA_abs, "STA $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " store accumulator ", " {adr}:=A ", abs_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8E , "STX", "abs", 3 , 4 , cpu_6502_STX_abs, "STX $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " store X ", " {adr}:=X ", abs_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8F , " *SAX ", "abs", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", "", "", abs_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x90 , "BCC", "rel", 2 , 3 , cpu_6502_BCC_rel, "BCC $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on carry clear ", " branch on C=0 ", rel_adr_mode, "    if (P.C == 0) GOTO (PC+M)  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x91 , "STA", "izy", 2 , 6 , cpu_6502_STA_izy, "STA ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "-------", " store accumulator ", " {adr}:=A ", izy_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x92 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "-------", "", "", izy_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x93 , " *AHX ", "izy", 2 , 6 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "-------", "", "", izy_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x94 , "STY", "zpx", 2 , 4 , cpu_6502_STY_zpx, "STY $AB,X", "zero page with index register X; ea = zpadr+X", "-------", " store Y ", " {adr}:=Y ", zpx_adr_mode, "    M = Y   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x95 , "STA", "zpx", 2 , 4 , cpu_6502_STA_zpx, "STA $AB,X", "zero page with index register X; ea = zpadr+X", "-------", " store accumulator ", " {adr}:=A ", zpx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x96 , "STX", "zpy", 2 , 4 , cpu_6502_STX_zpy, "STX $AB,X", "zero page with index register Y; ea = zpadr+Y", "-------", " store X ", " {adr}:=X ", zpy_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x97 , " *SAX ", "zpy", 2 , 4 , cpu_6502_illegal, "", "zero page with index register Y; ea = zpadr+Y", "-------", "", "", zpy_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x98 , "TYA", "imp", 1 , 2 , cpu_6502_TYA_imp, "TYA ", "implizit; no additional info needed", "*----*-", " transfer Y to accumulator ", " A:=Y ", imp_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x99 , "STA", "aby", 3 , 5 , cpu_6502_STA_aby, "STA $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "-------", " store accumulator ", " {adr}:=A ", aby_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9A , "TXS", "imp", 1 , 2 , cpu_6502_TXS_imp, "TXS ", "implizit; no additional info needed", "-------", " transfer X to stack pointer ", " S:=X ", imp_adr_mode, "    SP = X  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9B , " *TAS ", "aby", 0 , 5 , cpu_6502_illegal, "", "implizit; no additional info needed", "-------", "", "", imp_adr_mode, "    SP = X  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9C , " *SHY ", "abx", 3 , 5 , cpu_6502_illegal, "", "implizit; no additional info needed", "-------", "", "", imp_adr_mode, "    SP = X  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9D , "STA", "abx", 3 , 5 , cpu_6502_STA_abx, "STA $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "-------", " store accumulator ", " {adr}:=A ", abx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9E , " *SHX ", "aby", 3 , 5 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "-------", "", "", abx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9F , " *AHX ", "aby", 3 , 5 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "-------", "", "", abx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA0 , "LDY", "imm", 2 , 2 , cpu_6502_LDY_imm, "LDY #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " load Y ", " Y:={adr} ", imm_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA1 , "LDA", "izx", 2 , 6 , cpu_6502_LDA_izx, "LDA ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " load accumulator ", " A:={adr} ", izx_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA2 , "LDX", "imm", 2 , 2 , cpu_6502_LDX_imm, "LDX #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", "  ", " X:={adr} ", imm_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA3 , " *LAX ", "izx", 2 , 6 , cpu_6502_illegal, "", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", "", "", imm_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA4 , "LDY", "zp", 2 , 3 , cpu_6502_LDY_zp, "LDY $AB", "zero page ; ea = zpadr", "*----*-", " load Y ", " Y:={adr} ", zp_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA5 , "LDA", "zp", 2 , 3 , cpu_6502_LDA_zp, "LDA $AB", "zero page ; ea = zpadr", "*----*-", " load accumulator ", " A:={adr} ", zp_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA6 , "LDX", "zp", 2 , 3 , cpu_6502_LDX_zp, "LDX $AB", "zero page ; ea = zpadr", "*----*-", "  ", " X:={adr} ", zp_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA7 , " *LAX ", "zp", 2 , 3 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----*-", "", "", zp_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA8 , "TAY", "imp", 1 , 2 , cpu_6502_TAY_imp, "TAY ", "implizit; no additional info needed", "*----*-", " transfer accumulator to Y ", " Y:=A ", imp_adr_mode, "    Y = A \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA9 , "LDA", "imm", 2 , 2 , cpu_6502_LDA_imm, "LDA #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " load accumulator ", " A:={adr} ", imm_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAA , "TAX", "imp", 1 , 2 , cpu_6502_TAX_imp, "TAX ", "implizit; no additional info needed", "*----*-", " transfer accumulator to X ", " X:=A ", imp_adr_mode, "    X = A \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAB , " *LAX ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    X = A \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAC , "LDY", "abs", 3 , 4 , cpu_6502_LDY_abs, "LDY $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " load Y ", " Y:={adr} ", abs_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAD , "LDA", "abs", 3 , 4 , cpu_6502_LDA_abs, "LDA $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " load accumulator ", " A:={adr} ", abs_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAE , "LDX", "abs", 3 , 4 , cpu_6502_LDX_abs, "LDX $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "  ", " X:={adr} ", abs_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAF , " *LAX ", "abs", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "", "", abs_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB0 , "BCS", "rel", 2 , 2 , cpu_6502_BCS_rel, "BCS $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on carry set ", " branch on C=1 ", rel_adr_mode, "    if (P.C == 1) GOTO (PC+M)  \n \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB1 , "LDA", "izy", 2 , 5 , cpu_6502_LDA_izy, "LDA ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " load accumulator ", " A:={adr} ", izy_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB2 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB3 , " *LAX ", "izy", 2 , 5 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB4 , "LDY", "zpx", 2 , 4 , cpu_6502_LDY_zpx, "LDY $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " load Y ", " Y:={adr} ", zpx_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB5 , "LDA", "zpx", 2 , 4 , cpu_6502_LDA_zpx, "LDA $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " load accumulator ", " A:={adr} ", zpx_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB6 , "LDX", "zpy", 2 , 4 , cpu_6502_LDX_zpy, "LDX $AB,X", "zero page with index register Y; ea = zpadr+Y", "*----*-", "  ", " X:={adr} ", zpy_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB7 , " *LAX ", "zpy", 2 , 4 , cpu_6502_illegal, "", "zero page with index register Y; ea = zpadr+Y", "*----*-", "", "", zpy_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB8 , "CLV", "imp", 1 , 2 , cpu_6502_CLV_imp, "CLV ", "implizit; no additional info needed", "-0-----", " clear overflow ", " V:=0 ", imp_adr_mode, "    P.V = 0  \n \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB9 , "LDA", "aby", 3 , 4 , cpu_6502_LDA_aby, "LDA $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " load accumulator ", " A:={adr} ", aby_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBA , "TSX", "imp", 1 , 2 , cpu_6502_TSX_imp, "TSX ", "implizit; no additional info needed", "*----*-", " transfer stack pointer to X ", " X:=S ", imp_adr_mode, "    X = SP \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBB , " *LAS ", "aby", 3 , 4 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    X = SP \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBC , "LDY", "abx", 3 , 4 , cpu_6502_LDY_abx, "LDY $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " load Y ", " Y:={adr} ", abx_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBD , "LDA", "abx", 3 , 4 , cpu_6502_LDA_abx, "LDA $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " load accumulator ", " A:={adr} ", abx_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBE , "LDX", "aby", 3 , 4 , cpu_6502_LDX_aby, "LDX $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "  ", " X:={adr} ", aby_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBF , " *LAX ", "aby", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC0 , "CPY", "imm", 2 , 2 , cpu_6502_CPY_imm, "CPY #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----**", " compare with Y ", " Y-{adr} ", imm_adr_mode, "    t = Y - M \n    P.N = t.7 \n    P.C = (Y>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC1 , "CMP", "izx", 2 , 6 , cpu_6502_CMP_izx, "CMP ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----**", " compare (with accumulator) ", " A-{adr} ", izx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC2 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----**", "", "", izx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC3 , " *DCP ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----**", "", "", izx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC4 , "CPY", "zp", 2 , 3 , cpu_6502_CPY_zp, "CPY $AB", "zero page ; ea = zpadr", "*----**", " compare with Y ", " Y-{adr} ", zp_adr_mode, "    t = Y - M \n    P.N = t.7 \n    P.C = (Y>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC5 , "CMP", "zp", 2 , 3 , cpu_6502_CMP_zp, "CMP $AB", "zero page ; ea = zpadr", "*----**", " compare (with accumulator) ", " A-{adr} ", zp_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC6 , "DEC", "zp", 2 , 5 , cpu_6502_DEC_zp, "DEC $AB", "zero page ; ea = zpadr", "*----*-", " decrement ", " {adr}:={adr}-1 ", zp_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC7 , " *DCP ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----*-", "", "", zp_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC8 , "INY", "imp", 1 , 2 , cpu_6502_INY_imp, "INY ", "implizit; no additional info needed", "*----*-", " increment Y ", " Y:=Y+1 ", imp_adr_mode, "    Y = Y + 1 \n    P.Z = (Y==0) ? 1:0 \n    P.N = Y.7           \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC9 , "CMP", "imm", 2 , 2 , cpu_6502_CMP_imm, "CMP #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----**", " compare (with accumulator) ", " A-{adr} ", imm_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCA , "DEX", "imp", 1 , 2 , cpu_6502_DEX_imp, "DEX ", "implizit; no additional info needed", "*----*-", " decrement X ", " X:=X-1 ", imp_adr_mode, "    X = X - 1 \n    P.Z = (X==0) ? 1:0 \n    P.N = X.7           \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCB , " *AXS ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    X = X - 1 \n    P.Z = (X==0) ? 1:0 \n    P.N = X.7           \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCC , "CPY", "abs", 3 , 4 , cpu_6502_CPY_abs, "CPY $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " compare with Y ", " Y-{adr} ", abs_adr_mode, "    t = Y - M \n    P.N = t.7 \n    P.C = (Y>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCD , "CMP", "abs", 3 , 4 , cpu_6502_CMP_abs, "CMP $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " compare (with accumulator) ", " A-{adr} ", abs_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCE , "DEC", "abs", 3 , 6 , cpu_6502_DEC_abs, "DEC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " decrement ", " {adr}:={adr}-1 ", abs_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCF , " *DCP ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "", "", abs_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD0 , "BNE", "rel", 2 , 3 , cpu_6502_BNE_rel, "BNE $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on not equal (zero clear) ", " branch on Z=0 ", rel_adr_mode, "    if (P.Z == 0) GOTO (PC+M)  \n \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD1 , "CMP", "izy", 2 , 5 , cpu_6502_CMP_izy, "CMP ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", " compare (with accumulator) ", " A-{adr} ", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD2 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", "", "", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD3 , " *DCP ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", "", "", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD4 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", "", "", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD5 , "CMP", "zpx", 2 , 4 , cpu_6502_CMP_zpx, "CMP $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " compare (with accumulator) ", " A-{adr} ", zpx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD6 , "DEC", "zpx", 2 , 6 , cpu_6502_DEC_zpx, "DEC $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " decrement ", " {adr}:={adr}-1 ", zpx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD7 , " *DCP ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----*-", "", "", zpx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD8 , "CLD", "imp", 1 , 2 , cpu_6502_CLD_imp, "CLD ", "implizit; no additional info needed", "---0---", " clear decimal ", " D:=0 ", imp_adr_mode, "    P.D = 0  \n \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD9 , "CMP", "aby", 3 , 4 , cpu_6502_CMP_aby, "CMP $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", " compare (with accumulator) ", " A-{adr} ", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDA , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", "", "", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDB , " *DCP ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", "", "", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDC , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", "", "", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDD , "CMP", "abx", 3 , 4 , cpu_6502_CMP_abx, "CMP $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " compare (with accumulator) ", " A-{adr} ", abx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDE , "DEC", "abx", 3 , 7 , cpu_6502_DEC_abx, "DEC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " decrement ", " {adr}:={adr}-1 ", abx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDF , " *DCP ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", "", "", abx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xE0 , "CPX", "imm", 2 , 2 , cpu_6502_CPX_imm, "CPX #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----**", " compare with X ", " X-{adr} ", imm_adr_mode, "    t = X - M \n    P.N = t.7 \n    P.C = (X>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xE1 , "SBC", "izx", 2 , 6 , cpu_6502_SBC_izx, "SBC ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", " subtract with carry ", " A:=A-{adr} ", izx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE2 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE3 , " *ISC ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE4 , "CPX", "zp", 2 , 3 , cpu_6502_CPX_zp, "CPX $AB", "zero page ; ea = zpadr", "*----**", " compare with X ", " X-{adr} ", zp_adr_mode, "    t = X - M \n    P.N = t.7 \n    P.C = (X>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE5 , "SBC", "zp", 2 , 3 , cpu_6502_SBC_zp, "SBC $AB", "zero page ; ea = zpadr", "**---**", " subtract with carry ", " A:=A-{adr} ", zp_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE6 , "INC", "zp", 2 , 5 , cpu_6502_INC_zp, "INC $AB", "zero page ; ea = zpadr", "*----*-", " increment ", " {adr}:={adr}+1 ", zp_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE7 , " *ISC ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----*-", "", "", zp_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE8 , "INX", "imp", 1 , 2 , cpu_6502_INX_imp, "INX ", "implizit; no additional info needed", "*----*-", " increment X ", " X:=X+1 ", imp_adr_mode, "    X = X + 1 \n    P.Z = (X==0) ? 1:0 \n    P.N = X.7           \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE9 , "SBC", "imm", 2 , 2 , cpu_6502_SBC_imm, "SBC #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "**---**", " subtract with carry ", " A:=A-{adr} ", imm_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xEA , "NOP", "imp", 1 , 2 , cpu_6502_NOP_imp, "NOP ", "implizit; no additional info needed", "-------", " no operation ", "   ", imp_adr_mode, "    ~none~  \n \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xEB , " *SBC ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "-------", "", "", imp_adr_mode, "    ~none~  \n \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xEC , "CPX", "abs", 3 , 4 , cpu_6502_CPX_abs, "CPX $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " compare with X ", " X-{adr} ", abs_adr_mode, "    t = X - M \n    P.N = t.7 \n    P.C = (X>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xED , "SBC", "abs", 3 , 4 , cpu_6502_SBC_abs, "SBC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "**---**", " subtract with carry ", " A:=A-{adr} ", abs_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xEE , "INC", "abs", 3 , 6 , cpu_6502_INC_abs, "INC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " increment ", " {adr}:={adr}+1 ", abs_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xEF , " *ISC ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "", "", abs_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF0 , "BEQ", "rel", 2 , 2 , cpu_6502_BEQ_rel, "BEQ $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on equal (zero set) ", " branch on Z=1 ", rel_adr_mode, "    if (P.Z == 1) GOTO (PC+M)  \n \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF1 , "SBC", "izy", 2 , 5 , cpu_6502_SBC_izy, "SBC ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", " subtract with carry ", " A:=A-{adr} ", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF2 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF3 , " *ISC ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF4 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF5 , "SBC", "zpx", 2 , 4 , cpu_6502_SBC_zpx, "SBC $AB,X", "zero page with index register X; ea = zpadr+X", "**---**", " subtract with carry ", " A:=A-{adr} ", zpx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF6 , "INC", "zpx", 2 , 6 , cpu_6502_INC_zpx, "INC $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " increment ", " {adr}:={adr}+1 ", zpx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF7 , " *ISC ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----*-", "", "", zpx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF8 , "SED", "imp", 1 , 2 , cpu_6502_SED_imp, "SED ", "implizit; no additional info needed", "---1---", " set decimal ", " D:=1 ", imp_adr_mode, "    P.D = 1  \n \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF9 , "SBC", "aby", 3 , 4 , cpu_6502_SBC_aby, "SBC $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", " subtract with carry ", " A:=A-{adr} ", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFA , " *NOP ", "imp", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFB , " *ISC ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFC , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFD , "SBC", "abx", 3 , 4 , cpu_6502_SBC_abx, "SBC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "**---**", " subtract with carry ", " A:=A-{adr} ", abx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFE , "INC", "abx", 3 , 7 , cpu_6502_INC_abx, "INC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " increment ", " {adr}:={adr}+1 ", abx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFF , " *ISC ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", "", "", abx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" }
};
