/***
 Automatic generated by gen-opcodetable.bash
 not true anymore: added, illegal field
***/
#include "decode.h"
//#include "opcode_tbl.h"
#include "mu-code.h"
struct opcode_entry opcode_tbl[256] = {
  { 0x00, 0 , "BRK", "imp", 1 , 0 , cpu_6502_BRK_imp, "BRK ", "implizit; no additional info needed", "--1-1--", " interrupt ", " (S)-=:PC,P PC:=($FFFE) ", imp_adr_mode, "    PC = PC + 1 \n    bPoke(SP,PC.h) \n    SP = SP - 1 \n    bPoke(SP,PC.l) \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x01, 0 , "ORA", "izx", 2 , 6 , cpu_6502_ORA_izx, "ORA ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " or with accumulator ", " A:=A or {adr} ", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x02, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x03, 1 , " *SLO ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x04, 1 , " *NOP ", "zp", 2 , 3 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x05, 0 , "ORA", "zp", 2 , 3 , cpu_6502_ORA_zp, "ORA $AB", "zero page ; ea = zpadr", "*----*-", " or with accumulator ", " A:=A or {adr} ", zp_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x06, 0 , "ASL", "zp", 2 , 5 , cpu_6502_ASL_zp, "ASL $AB", "zero page ; ea = zpadr", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", zp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x07, 1 , " *SLO ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x08, 0 , "PHP", "imp", 1 , 3 , cpu_6502_PHP_imp, "PHP ", "implizit; no additional info needed", "-------", " push processor status (SR) ", " (S)-:=P ", imp_adr_mode, "    bPoke(SP,P) \n    SP = SP - 1  \n \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x09, 0 , "ORA", "imm", 2 , 2 , cpu_6502_ORA_imm, "ORA #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " or with accumulator ", " A:=A or {adr} ", imm_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x0A, 0 , "ASL", "imp", 1 , 2 , cpu_6502_ASL_imp, "ASL ", "implizit; no additional info needed", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", imp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0B, 1 , " *ANC ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0C, 1 , " *NOP ", "abs", 3 , 4 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x0D, 0 , "ORA", "abs", 3 , 4 , cpu_6502_ORA_abs, "ORA $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " or with accumulator ", " A:=A or {adr} ", abs_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x0E, 0 , "ASL", "abs", 3 , 6 , cpu_6502_ASL_abs, "ASL $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", abs_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x0F, 1 , " *SLO ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x10, 0, "BPL", "rel", 2 , 3 , cpu_6502_BPL_rel, "BPL $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on plus (negative clear) ", " branch on N=0 ", rel_adr_mode, "    if (P.N == 0) GOTO (PC+M)  \n \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x11, 0 , "ORA", "izy", 2 , 5 , cpu_6502_ORA_izy, "ORA ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " or with accumulator ", " A:=A or {adr} ", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x12, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x13, 1 , " *SLO ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x14, 1 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x15, 0 , "ORA", "zpx", 2 , 4 , cpu_6502_ORA_zpx, "ORA $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " or with accumulator ", " A:=A or {adr} ", zpx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x16, 0 , "ASL", "zpx", 2 , 6 , cpu_6502_ASL_zpx, "ASL $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", zpx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x17, 1 , " *SLO ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x18, 1 , "CLC", "imp", 1 , 2 , cpu_6502_CLC_imp, "CLC ", "implizit; no additional info needed", "------0", " clear carry ", " C:=0 ", imp_adr_mode, "    P.C = 0  \n \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x19, 0 , "ORA", "aby", 3 , 4 , cpu_6502_ORA_aby, "ORA $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " or with accumulator ", " A:=A or {adr} ", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1A, 1 , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1B, 1 , " *SLO ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1C, 1 , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x1D, 0 , "ORA", "abx", 3 , 4 , cpu_6502_ORA_abx, "ORA $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " or with accumulator ", " A:=A or {adr} ", abx_adr_mode, "    A = A | M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x1E, 1 , "ASL", "abx", 3 , 7 , cpu_6502_ASL_abx, "ASL $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " arithmetic shift left ", " {adr}:={adr}*2 ", abx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x1F, 1 , " *SLO ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    P.C = B.7 \n    B = (B << 1) & $FE \n    P.N = B.7 \n    P.Z = (B==0) ? 1:0  \n \n    bPoke(SP, (P|$10) ) \n    SP = SP - 1 \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x20, 0 , "JSR", "abs", 3 , 6 , cpu_6502_JSR_abs, "JSR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " jump subroutine ", " (S)-:=PC PC:={adr} ", abs_adr_mode, "    t = PC - 1 \n    bPoke(SP,t.h) \n    SP = SP - 1 \n    bPoke(SP,t.l) \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x21, 0 , "AND", "izx", 2 , 6 , cpu_6502_AND_izx, "AND ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", izx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x22, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x23, 1 , " *RLA ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x24, 0 , "BIT", "zp", 2 , 3 , cpu_6502_BIT_zp, "BIT $AB", "zero page ; ea = zpadr", "**---*-", " bit test ", " N:=b7 V:=b6 Z:=A&{adr} ", zp_adr_mode, "    t = A & M \n    P.N = t.7 \n    P.V = t.6 \n    P.Z = (t==0) ? 1:0  \n \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x25, 0 , "AND", "zp", 2 , 3 , cpu_6502_AND_zp, "AND $AB", "zero page ; ea = zpadr", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", zp_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    PC = $A5B6     \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x26, 0 , "ROL", "zp", 2 , 5 , cpu_6502_ROL_zp, "ROL $AB", "zero page ; ea = zpadr", "*----**", " rotate left ", " {adr}:={adr}*2+C ", zp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x27, 1 , " *RLA ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x28, 0 , "PLP", "imp", 1 , 4 , cpu_6502_PLP_imp, "PLP ", "implizit; no additional info needed", "**-****", " pull processor status (SR) ", " P:=+(S) ", imp_adr_mode, "    SP = SP + 1 \n    P = bPeek(SP)   \n \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x29, 0 , "AND", "imm", 2 , 2 , cpu_6502_AND_imm, "AND #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", imm_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x2A, 0 , "ROL", "imp", 1 , 2 , cpu_6502_ROL_imp, "ROL ", "implizit; no additional info needed", "*----**", " rotate left ", " {adr}:={adr}*2+C ", imp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2B, 1 , " *ANC ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x2C, 0 , "BIT", "abs", 3 , 4 , cpu_6502_BIT_abs, "BIT $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "**---*-", " bit test ", " N:=b7 V:=b6 Z:=A&{adr} ", abs_adr_mode, "    t = A & M \n    P.N = t.7 \n    P.V = t.6 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x2D, 0 , "AND", "abs", 3 , 4 , cpu_6502_AND_abs, "AND $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", abs_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x2E, 0 , "ROL", "abs", 3 , 6 , cpu_6502_ROL_abs, "ROL $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " rotate left ", " {adr}:={adr}*2+C ", abs_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x2F, 1 , " *RLA ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x30, 0 , "BMI", "rel", 2 , 2 , cpu_6502_BMI_rel, "BMI $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on minus (negative set) ", " branch on N=1 ", rel_adr_mode, "    if (P.N == 1) GOTO (PC+M)  \n \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x31, 0 , "AND", "izy", 2 , 5 , cpu_6502_AND_izy, "AND ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x32, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x33, 1 , " *RLA ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x34, 1 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x35, 0 , "AND", "zpx", 2 , 4 , cpu_6502_AND_zpx, "AND $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", zpx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x36, 0 , "ROL", "zpx", 2 , 6 , cpu_6502_ROL_zpx, "ROL $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " rotate left ", " {adr}:={adr}*2+C ", zpx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x37, 1 , " *RLA ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x38, 0 , "SEC", "imp", 1 , 2 , cpu_6502_SEC_imp, "SEC ", "implizit; no additional info needed", "------1", " set carry ", " C:=1 ", imp_adr_mode, "    P.C = 1  \n \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x39, 0 , "AND", "aby", 3 , 4 , cpu_6502_AND_aby, "AND $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3A, 1 , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3B, 1 , " *RLA ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3C, 1 , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x3D, 0 , "AND", "abx", 3 , 4 , cpu_6502_AND_abx, "AND $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " and (with accumulator) ", " A:=A&{adr} ", abx_adr_mode, "    A = A & M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x3E, 1 , "ROL", "abx", 3 , 7 , cpu_6502_ROL_abx, "ROL $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " rotate left ", " {adr}:={adr}*2+C ", abx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x3F, 1 , " *RLA ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    t = B.7 \n    B = (B << 1) & $FE \n    B = B | P.C \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7           \n \n    l = bPeek($FFFE) \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x40, 0 , "RTI", "imp", 1 , 6 , cpu_6502_RTI_imp, "RTI ", "implizit; no additional info needed", "**-****", " return from interrupt ", " P,PC:=+(S) ", imp_adr_mode, "    SP = SP - 1 \n    P = bPeek(SP) \n    SP = SP - 1 \n    l = bPeek(SP) \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x41, 0 , "EOR", "izx", 2 , 6 , cpu_6502_EOR_izx, "EOR ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x42, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x43, 1 , " *SRE ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x44, 1 , " *NOP ", "zp", 2 , 3 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", "", "", izx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x45, 0 , "EOR", "zp", 2 , 3 , cpu_6502_EOR_zp, "EOR $AB", "zero page ; ea = zpadr", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", zp_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    SP = SP - 1 \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x46, 0 , "LSR", "zp", 2 , 5 , cpu_6502_LSR_zp, "LSR $AB", "zero page ; ea = zpadr", "*----**", " logical shift right ", " {adr}:={adr}/2 ", zp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x47, 1 , " *SRE ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x48, 0 , "PHA", "imp", 1 , 3 , cpu_6502_PHA_imp, "PHA ", "implizit; no additional info needed", "-------", " push accumulator ", " (S)-:=A ", imp_adr_mode, "    bPoke(SP,A) \n    SP = SP - 1  \n \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x49, 0 , "EOR", "imm", 2 , 2 , cpu_6502_EOR_imm, "EOR #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", imm_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x4A, 0 , "LSR", "imp", 1 , 2 , cpu_6502_LSR_imp, "LSR ", "implizit; no additional info needed", "*----**", " logical shift right ", " {adr}:={adr}/2 ", imp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4B, 1 , " *ALR ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x4C, 0 , "JMP", "abs", 3 , 3 , cpu_6502_JMP_abs, "JMP $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " jump ", " PC:={adr} ", abs_adr_mode, "    PC = M  \n \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x4D, 0 , "EOR", "abs", 3 , 4 , cpu_6502_EOR_abs, "EOR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", abs_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x4E, 0 , "LSR", "abs", 3 , 6 , cpu_6502_LSR_abs, "LSR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " logical shift right ", " {adr}:={adr}/2 ", abs_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x4F, 1 , " *SRE ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x50, 0 , "BVC", "rel", 2 , 3 , cpu_6502_BVC_rel, "BVC $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on overflow clear ", " branch on V=0 ", rel_adr_mode, "    if (P.V == 0) GOTO (PC+M)  \n \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x51, 0 , "EOR", "izy", 2 , 5 , cpu_6502_EOR_izy, "EOR ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x52, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x53, 1 , " *SRE ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x54, 1 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x55, 0 , "EOR", "zpx", 2 , 4 , cpu_6502_EOR_zpx, "EOR $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", zpx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x56, 0 , "LSR", "zpx", 2 , 6 , cpu_6502_LSR_zpx, "LSR $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " logical shift right ", " {adr}:={adr}/2 ", zpx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x57, 1 , " *SRE ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x58, 1 , "CLI", "imp", 1 , 2 , cpu_6502_CLI_imp, "CLI ", "implizit; no additional info needed", "----0--", " clear interrupt disable ", " I:=0 ", imp_adr_mode, "    P.I = 0  \n \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x59, 0 , "EOR", "aby", 3 , 4 , cpu_6502_EOR_aby, "EOR $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5A, 1 , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5B, 1 , " *SRE ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5C, 1 , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x5D, 0 , "EOR", "abx", 3 , 4 , cpu_6502_EOR_abx, "EOR $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " exclusive or (with accumulator) ", " A:=A exor {adr} ", abx_adr_mode, "    A = A ^ M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x5E, 0 , "LSR", "abx", 3 , 7 , cpu_6502_LSR_abx, "LSR $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " logical shift right ", " {adr}:={adr}/2 ", abx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
{ 0x5F, 1 , " *SRE ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    P.N = 0 \n    P.C = B.0 \n    B = (B >> 1) & $7F \n    P.Z = (B==0) ? 1:0  \n \n    h = bPeek(SP)<<8 \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x60, 0 , "RTS", "imp", 1 , 6 , cpu_6502_RTS_imp, "RTS ", "implizit; no additional info needed", "-------", " return from subroutine ", " PC:=+(S) ", imp_adr_mode, "    SP = SP + 1 \n    l = bPeek(SP) \n    SP = SP + 1 \n    h = bPeek(SP)<<8 \n    PC = (h|l) +1     \n \n    PC = h|l          \n \n    h = bPeek($FFFF)<<8 \n    PC = h|l              \n \n" },
  { 0x61, 0 , "ADC", "izx", 2 , 6 , cpu_6502_ADC_izx, "ADC ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", " add with carry ", " A:=A+{adr} ", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x62, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x63, 1 , " *RRA ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x64, 1 , " *NOP ", "zp", 2 , 3 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x65, 0 , "ADC", "zp", 2 , 3 , cpu_6502_ADC_zp, "ADC $AB", "zero page ; ea = zpadr", "**---**", " add with carry ", " A:=A+{adr} ", zp_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
  { 0x66, 0 , "ROR", "zp", 2 , 5 , cpu_6502_ROR_zp, "ROR $AB", "zero page ; ea = zpadr", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", zp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
{ 0x67, 1 , " *RRA ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----**", "", "", zp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
  { 0x68, 0 , "PLA", "imp", 1 , 4 , cpu_6502_PLA_imp, "PLA ", "implizit; no additional info needed", "*----*-", " pull accumulator ", " A:=+(S) ", imp_adr_mode, "    SP = SP + 1 \n    A = bPeek(SP) \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF   \n \n" },
  { 0x69, 0 , "ADC", "imm", 2 , 2 , cpu_6502_ADC_imm, "ADC #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "**---**", " add with carry ", " A:=A+{adr} ", imm_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x6A, 0 , "ROR", "imp", 1 , 2 , cpu_6502_ROR_imp, "ROR ", "implizit; no additional info needed", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", imp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6B, 1 , " *ARR ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----**", "", "", imp_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x6C, 0 , "JMP", "ind", 3 , 5 , cpu_6502_JMP_ind, "JMP $ABCD", "indirect; indirection via zp address; ea = mem[zpadr+1]|mem[zpadr]", "-------", " jump ", " PC:={adr} ", ind_adr_mode, "    PC = M  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x6D, 0 , "ADC", "abs", 3 , 4 , cpu_6502_ADC_abs, "ADC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "**---**", " add with carry ", " A:=A+{adr} ", abs_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x6E, 0 , "ROR", "abs", 3 , 6 , cpu_6502_ROR_abs, "ROR $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", abs_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x6F, 1 , " *RRA ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", "", "", abs_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x70, 0 , "BVS", "rel", 2 , 2 , cpu_6502_BVS_rel, "BVS $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on overflow set ", " branch on V=1 ", rel_adr_mode, "    if (P.V == 1) GOTO (PC+M)  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x71, 0 , "ADC", "izy", 2 , 5 , cpu_6502_ADC_izy, "ADC ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", " add with carry ", " A:=A+{adr} ", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x72, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x73, 1 , " *RRA ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x74, 1 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x75, 0 , "ADC", "zpx", 2 , 4 , cpu_6502_ADC_zpx, "ADC $AB,X", "zero page with index register X; ea = zpadr+X", "**---**", " add with carry ", " A:=A+{adr} ", zpx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x76, 0 , "ROR", "zpx", 2 , 6 , cpu_6502_ROR_zpx, "ROR $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", zpx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x77, 1 , " *RRA ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----**", "", "", zpx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x78, 0 , "SEI", "imp", 1 , 2 , cpu_6502_SEI_imp, "SEI ", "implizit; no additional info needed", "----1--", " set interrupt disable ", " I:=1 ", imp_adr_mode, "    P.I = 1  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x79, 0 , "ADC", "aby", 3 , 4 , cpu_6502_ADC_aby, "ADC $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", " add with carry ", " A:=A+{adr} ", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7A, 1 , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7B, 1 , " *RRA ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7C, 1 , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x7D, 0 , "ADC", "abx", 3 , 4 , cpu_6502_ADC_abx, "ADC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "**---**", " add with carry ", " A:=A+{adr} ", abx_adr_mode, "    t = A + M + P.C \n    P.V = (A.7!=t.7) ? 1:0 \n    P.N = A.7 \n    P.Z = (t==0) ? 1:0 \n    IF (P.D) \n      t = bcd(A) + bcd(M) + P.C \n      P.C = (t>99) ? 1:0 \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x7E, 0 , "ROR", "abx", 3 , 7 , cpu_6502_ROR_abx, "ROR $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " rotate right ", " {adr}:={adr}/2+C*128 ", abx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x7F, 1 , " *RRA ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x80, 1 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", "", "", abx_adr_mode, "    t = B.0 \n    B = (B >> 1) & $7F \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x81, 0 , "STA", "izx", 2 , 6 , cpu_6502_STA_izx, "STA ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "-------", " store accumulator ", " {adr}:=A ", izx_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x82, 1 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "-------", "", "", izx_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x83, 1 , " *SAX ", "izx", 2 , 6 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "-------", "", "", izx_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x84, 0 , "STY", "zp", 2 , 3 , cpu_6502_STY_zp, "STY $AB", "zero page ; ea = zpadr", "-------", " store Y ", " {adr}:=Y ", zp_adr_mode, "    M = Y   \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x85, 0 , "STA", "zp", 2 , 3 , cpu_6502_STA_zp, "STA $AB", "zero page ; ea = zpadr", "-------", " store accumulator ", " {adr}:=A ", zp_adr_mode, "    M = A  \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x86, 0 , "STX", "zp", 2 , 3 , cpu_6502_STX_zp, "STX $AB", "zero page ; ea = zpadr", "-------", " store X ", " {adr}:=X ", zp_adr_mode, "    M = X   \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x87, 1 , " *SAX ", "zp", 2 , 3 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "-------", "", "", zp_adr_mode, "    M = X   \n \n    B = B | ((P.C) ? $80:$00) \n    P.C = t \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x88, 0 , "DEY", "imp", 1 , 2 , cpu_6502_DEY_imp, "DEY ", "implizit; no additional info needed", "*----*-", " decrement Y ", " Y:=Y-1 ", imp_adr_mode, "    Y = Y - 1 \n    P.Z = (Y==0) ? 1:0 \n    P.N = Y.7           \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x89, 1 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    Y = Y - 1 \n    P.Z = (Y==0) ? 1:0 \n    P.N = Y.7           \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x8A, 0 , "TXA", "imp", 1 , 2 , cpu_6502_TXA_imp, "TXA ", "implizit; no additional info needed", "*----*-", " transfer X to accumulator ", " A:=X ", imp_adr_mode, "    A = X \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8B, 1 , " *XAA ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    A = X \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x8C, 0 , "STY", "abs", 3 , 4 , cpu_6502_STY_abs, "STY $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " store Y ", " {adr}:=Y ", abs_adr_mode, "    M = Y   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x8D, 0 , "STA", "abs", 3 , 4 , cpu_6502_STA_abs, "STA $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " store accumulator ", " {adr}:=A ", abs_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x8E, 0 , "STX", "abs", 3 , 4 , cpu_6502_STX_abs, "STX $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", " store X ", " {adr}:=X ", abs_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x8F, 1 , " *SAX ", "abs", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "-------", "", "", abs_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x90, 0 , "BCC", "rel", 2 , 3 , cpu_6502_BCC_rel, "BCC $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on carry clear ", " branch on C=0 ", rel_adr_mode, "    if (P.C == 0) GOTO (PC+M)  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x91, 0 , "STA", "izy", 2 , 6 , cpu_6502_STA_izy, "STA ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "-------", " store accumulator ", " {adr}:=A ", izy_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x92, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "-------", "", "", izy_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x93, 1 , " *AHX ", "izy", 2 , 6 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "-------", "", "", izy_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x94, 0 , "STY", "zpx", 2 , 4 , cpu_6502_STY_zpx, "STY $AB,X", "zero page with index register X; ea = zpadr+X", "-------", " store Y ", " {adr}:=Y ", zpx_adr_mode, "    M = Y   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x95, 0 , "STA", "zpx", 2 , 4 , cpu_6502_STA_zpx, "STA $AB,X", "zero page with index register X; ea = zpadr+X", "-------", " store accumulator ", " {adr}:=A ", zpx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x96, 0 , "STX", "zpy", 2 , 4 , cpu_6502_STX_zpy, "STX $AB,X", "zero page with index register Y; ea = zpadr+Y", "-------", " store X ", " {adr}:=X ", zpy_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x97, 1 , " *SAX ", "zpy", 2 , 4 , cpu_6502_illegal, "", "zero page with index register Y; ea = zpadr+Y", "-------", "", "", zpy_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x98, 0 , "TYA", "imp", 1 , 2 , cpu_6502_TYA_imp, "TYA ", "implizit; no additional info needed", "*----*-", " transfer Y to accumulator ", " A:=Y ", imp_adr_mode, "    M = X   \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x99, 0 , "STA", "aby", 3 , 5 , cpu_6502_STA_aby, "STA $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "-------", " store accumulator ", " {adr}:=A ", aby_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x9A, 0 , "TXS", "imp", 1 , 2 , cpu_6502_TXS_imp, "TXS ", "implizit; no additional info needed", "-------", " transfer X to stack pointer ", " S:=X ", imp_adr_mode, "    SP = X  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9B, 1 , " *TAS ", "aby", 0 , 5 , cpu_6502_illegal, "", "implizit; no additional info needed", "-------", "", "", imp_adr_mode, "    SP = X  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9C, 1 , " *SHY ", "abx", 3 , 5 , cpu_6502_illegal, "", "implizit; no additional info needed", "-------", "", "", imp_adr_mode, "    SP = X  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0x9D, 0 , "STA", "abx", 3 , 5 , cpu_6502_STA_abx, "STA $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "-------", " store accumulator ", " {adr}:=A ", abx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9E, 1 , " *SHX ", "aby", 3 , 5 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "-------", "", "", abx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0x9F, 1 , " *AHX ", "aby", 3 , 5 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "-------", "", "", abx_adr_mode, "    M = A  \n \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA0, 0 , "LDY", "imm", 2 , 2 , cpu_6502_LDY_imm, "LDY #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " load Y ", " Y:={adr} ", imm_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA1, 0 , "LDA", "izx", 2 , 6 , cpu_6502_LDA_izx, "LDA ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----*-", " load accumulator ", " A:={adr} ", izx_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA2, 0 , "LDX", "imm", 2 , 2 , cpu_6502_LDX_imm, "LDX #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", "  ", " X:={adr} ", imm_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA3, 1 , " *LAX ", "izx", 2 , 6 , cpu_6502_illegal, "", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", "", "", imm_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA4, 0 , "LDY", "zp", 2 , 3 , cpu_6502_LDY_zp, "LDY $AB", "zero page ; ea = zpadr", "*----*-", " load Y ", " Y:={adr} ", zp_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA5, 0 , "LDA", "zp", 2 , 3 , cpu_6502_LDA_zp, "LDA $AB", "zero page ; ea = zpadr", "*----*-", " load accumulator ", " A:={adr} ", zp_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA6, 0 , "LDX", "zp", 2 , 3 , cpu_6502_LDX_zp, "LDX $AB", "zero page ; ea = zpadr", "*----*-", "  ", " X:={adr} ", zp_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xA7, 1 , " *LAX ", "zp", 2 , 3 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----*-", "", "", zp_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA8, 0 , "TAY", "imp", 1 , 2 , cpu_6502_TAY_imp, "TAY ", "implizit; no additional info needed", "*----*-", " transfer accumulator to Y ", " Y:=A ", imp_adr_mode, "    Y = A \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xA9, 0 , "LDA", "imm", 2 , 2 , cpu_6502_LDA_imm, "LDA #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----*-", " load accumulator ", " A:={adr} ", imm_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xAA, 0 , "TAX", "imp", 1 , 2 , cpu_6502_TAX_imp, "TAX ", "implizit; no additional info needed", "*----*-", " transfer accumulator to X ", " X:=A ", imp_adr_mode, "    X = A \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAB, 1 , " *LAX ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    X = A \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xAC, 0 , "LDY", "abs", 3 , 4 , cpu_6502_LDY_abs, "LDY $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " load Y ", " Y:={adr} ", abs_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xAD, 0 , "LDA", "abs", 3 , 4 , cpu_6502_LDA_abs, "LDA $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " load accumulator ", " A:={adr} ", abs_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xAE, 0 , "LDX", "abs", 3 , 4 , cpu_6502_LDX_abs, "LDX $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "  ", " X:={adr} ", abs_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xAF, 1 , " *LAX ", "abs", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "", "", abs_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xB0, 0 , "BCS", "rel", 2 , 2 , cpu_6502_BCS_rel, "BCS $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on carry set ", " branch on C=1 ", rel_adr_mode, "    if (P.C == 1) GOTO (PC+M)  \n \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xB1, 0 , "LDA", "izy", 2 , 5 , cpu_6502_LDA_izy, "LDA ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", " load accumulator ", " A:={adr} ", izy_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB2, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB3, 1 , " *LAX ", "izy", 2 , 5 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----*-", "", "", izy_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xB4, 0 , "LDY", "zpx", 2 , 4 , cpu_6502_LDY_zpx, "LDY $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " load Y ", " Y:={adr} ", zpx_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xB5, 0 , "LDA", "zpx", 2 , 4 , cpu_6502_LDA_zpx, "LDA $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " load accumulator ", " A:={adr} ", zpx_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xB6, 0 , "LDX", "zpy", 2 , 4 , cpu_6502_LDX_zpy, "LDX $AB,X", "zero page with index register Y; ea = zpadr+Y", "*----*-", "  ", " X:={adr} ", zpy_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xB7, 1 , " *LAX ", "zpy", 2 , 4 , cpu_6502_illegal, "", "zero page with index register Y; ea = zpadr+Y", "*----*-", "", "", zpy_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xB8, 0 , "CLV", "imp", 1 , 2 , cpu_6502_CLV_imp, "CLV ", "implizit; no additional info needed", "-0-----", " clear overflow ", " V:=0 ", imp_adr_mode, "    P.V = 0  \n \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xB9, 0 , "LDA", "aby", 3 , 4 , cpu_6502_LDA_aby, "LDA $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", " load accumulator ", " A:={adr} ", aby_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xBA, 0 , "TSX", "imp", 1 , 2 , cpu_6502_TSX_imp, "TSX ", "implizit; no additional info needed", "*----*-", " transfer stack pointer to X ", " X:=S ", imp_adr_mode, "    X = SP \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBB, 1 , " *LAS ", "aby", 3 , 4 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    X = SP \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xBC, 0 , "LDY", "abx", 3 , 4 , cpu_6502_LDY_abx, "LDY $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " load Y ", " Y:={adr} ", abx_adr_mode, "    Y = M \n    P.N = Y.7 \n    P.Z = (Y==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xBD, 0 , "LDA", "abx", 3 , 4 , cpu_6502_LDA_abx, "LDA $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " load accumulator ", " A:={adr} ", abx_adr_mode, "    A = M \n    P.N = A.7 \n    P.Z = (A==0) ? 1:0  \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xBE, 0 , "LDX", "aby", 3 , 4 , cpu_6502_LDX_aby, "LDX $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "  ", " X:={adr} ", aby_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xBF, 1 , " *LAX ", "aby", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----*-", "", "", aby_adr_mode, "    X = M \n    P.N = X.7 \n    P.Z = (X==0) ? 1:0 \n \n    P.Z = (B==0) ? 1:0 \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xC0, 0 , "CPY", "imm", 2 , 2 , cpu_6502_CPY_imm, "CPY #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----**", " compare with Y ", " Y-{adr} ", imm_adr_mode, "    t = Y - M \n    P.N = t.7 \n    P.C = (Y>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xC1, 0 , "CMP", "izx", 2 , 6 , cpu_6502_CMP_izx, "CMP ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----**", " compare (with accumulator) ", " A-{adr} ", izx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC2, 1 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----**", "", "", izx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC3, 1 , " *DCP ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "*----**", "", "", izx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xC4, 0 , "CPY", "zp", 2 , 3 , cpu_6502_CPY_zp, "CPY $AB", "zero page ; ea = zpadr", "*----**", " compare with Y ", " Y-{adr} ", zp_adr_mode, "    t = Y - M \n    P.N = t.7 \n    P.C = (Y>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xC5, 0 , "CMP", "zp", 2 , 3 , cpu_6502_CMP_zp, "CMP $AB", "zero page ; ea = zpadr", "*----**", " compare (with accumulator) ", " A-{adr} ", zp_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xC6, 0 , "DEC", "zp", 2 , 5 , cpu_6502_DEC_zp, "DEC $AB", "zero page ; ea = zpadr", "*----*-", " decrement ", " {adr}:={adr}-1 ", zp_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xC7, 1 , " *DCP ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----*-", "", "", zp_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xC8, 0 , "INY", "imp", 1 , 2 , cpu_6502_INY_imp, "INY ", "implizit; no additional info needed", "*----*-", " increment Y ", " Y:=Y+1 ", imp_adr_mode, "    Y = Y + 1 \n    P.Z = (Y==0) ? 1:0 \n    P.N = Y.7           \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xC9, 0 , "CMP", "imm", 2 , 2 , cpu_6502_CMP_imm, "CMP #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----**", " compare (with accumulator) ", " A-{adr} ", imm_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xCA, 0 , "DEX", "imp", 1 , 2 , cpu_6502_DEX_imp, "DEX ", "implizit; no additional info needed", "*----*-", " decrement X ", " X:=X-1 ", imp_adr_mode, "    X = X - 1 \n    P.Z = (X==0) ? 1:0 \n    P.N = X.7           \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCB, 1 , " *AXS ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "*----*-", "", "", imp_adr_mode, "    X = X - 1 \n    P.Z = (X==0) ? 1:0 \n    P.N = X.7           \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xCC, 0 , "CPY", "abs", 3 , 4 , cpu_6502_CPY_abs, "CPY $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " compare with Y ", " Y-{adr} ", abs_adr_mode, "    t = Y - M \n    P.N = t.7 \n    P.C = (Y>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xCD, 0 , "CMP", "abs", 3 , 4 , cpu_6502_CMP_abs, "CMP $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " compare (with accumulator) ", " A-{adr} ", abs_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xCE, 0 , "DEC", "abs", 3 , 6 , cpu_6502_DEC_abs, "DEC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " decrement ", " {adr}:={adr}-1 ", abs_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xCF, 1 , " *DCP ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "", "", abs_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xD0, 0 , "BNE", "rel", 2 , 3 , cpu_6502_BNE_rel, "BNE $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on not equal (zero clear) ", " branch on Z=0 ", rel_adr_mode, "    if (P.Z == 0) GOTO (PC+M)  \n \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xD1, 0 , "CMP", "izy", 2 , 5 , cpu_6502_CMP_izy, "CMP ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", " compare (with accumulator) ", " A-{adr} ", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD2, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", "", "", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD3, 1 , " *DCP ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", "", "", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD4, 1 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "*----**", "", "", izy_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xD5, 0 , "CMP", "zpx", 2 , 4 , cpu_6502_CMP_zpx, "CMP $AB,X", "zero page with index register X; ea = zpadr+X", "*----**", " compare (with accumulator) ", " A-{adr} ", zpx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xD6, 0 , "DEC", "zpx", 2 , 6 , cpu_6502_DEC_zpx, "DEC $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " decrement ", " {adr}:={adr}-1 ", zpx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xD7, 1 , " *DCP ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----*-", "", "", zpx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xD8, 0 , "CLD", "imp", 1 , 2 , cpu_6502_CLD_imp, "CLD ", "implizit; no additional info needed", "---0---", " clear decimal ", " D:=0 ", imp_adr_mode, "    P.D = 0  \n \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xD9, 0 , "CMP", "aby", 3 , 4 , cpu_6502_CMP_aby, "CMP $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", " compare (with accumulator) ", " A-{adr} ", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDA, 1 , " *NOP ", " imp ", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", "", "", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDB, 1 , " *DCP ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", "", "", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDC, 1 , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "*----**", "", "", aby_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xDD, 0 , "CMP", "abx", 3 , 4 , cpu_6502_CMP_abx, "CMP $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----**", " compare (with accumulator) ", " A-{adr} ", abx_adr_mode, "    t = A - M \n    P.N = t.7 \n    P.C = (A>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xDE, 0 , "DEC", "abx", 3 , 7 , cpu_6502_DEC_abx, "DEC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " decrement ", " {adr}:={adr}-1 ", abx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
{ 0xDF, 1 , " *DCP ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", "", "", abx_adr_mode, "    M = (M - 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xE0, 0 , "CPX", "imm", 2 , 2 , cpu_6502_CPX_imm, "CPX #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "*----**", " compare with X ", " X-{adr} ", imm_adr_mode, "    t = X - M \n    P.N = t.7 \n    P.C = (X>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n    P.N = B.7                  \n \n    ELSE \n      P.C = (t>255) ? 1:0 \n    A = t & 0xFF                 \n \n" },
  { 0xE1, 0 , "SBC", "izx", 2 , 6 , cpu_6502_SBC_izx, "SBC ($A5,X)", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", " subtract with carry ", " A:=A-{adr} ", izx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE2, 1 , " *NOP ", " imm ", 2 , 2 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE3, 1 , " *ISC ", "izx", 2 , 8 , cpu_6502_illegal, "", "indirect X-indexed zero page; ea = mem[zpadr+X|zpadr+X+1]", "**---**", "", "", izx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xE4, 0 , "CPX", "zp", 2 , 3 , cpu_6502_CPX_zp, "CPX $AB", "zero page ; ea = zpadr", "*----**", " compare with X ", " X-{adr} ", zp_adr_mode, "    t = X - M \n    P.N = t.7 \n    P.C = (X>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xE5, 0 , "SBC", "zp", 2 , 3 , cpu_6502_SBC_zp, "SBC $AB", "zero page ; ea = zpadr", "**---**", " subtract with carry ", " A:=A-{adr} ", zp_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xE6, 1 , "INC", "zp", 2 , 5 , cpu_6502_INC_zp, "INC $AB", "zero page ; ea = zpadr", "*----*-", " increment ", " {adr}:={adr}+1 ", zp_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xE7, 1 , " *ISC ", "zp", 2 , 5 , cpu_6502_illegal, "", "zero page ; ea = zpadr", "*----*-", "", "", zp_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xE8, 1 , "INX", "imp", 1 , 2 , cpu_6502_INX_imp, "INX ", "implizit; no additional info needed", "*----*-", " increment X ", " X:=X+1 ", imp_adr_mode, "    X = X + 1 \n    P.Z = (X==0) ? 1:0 \n    P.N = X.7           \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xE9, 0 , "SBC", "imm", 2 , 2 , cpu_6502_SBC_imm, "SBC #$AB    ", "immediate -- data immediate after opcode; data = mem[PC+1]", "**---**", " subtract with carry ", " A:=A-{adr} ", imm_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xEA, 0 , "NOP", "imp", 1 , 2 , cpu_6502_NOP_imp, "NOP ", "implizit; no additional info needed", "-------", " no operation ", "   ", imp_adr_mode, "    ~none~  \n \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xEB, 1 , " *SBC ", " imm ", 2 , 2 , cpu_6502_illegal, "", "implizit; no additional info needed", "-------", "", "", imp_adr_mode, "    ~none~  \n \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xEC, 0 , "CPX", "abs", 3 , 4 , cpu_6502_CPX_abs, "CPX $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----**", " compare with X ", " X-{adr} ", abs_adr_mode, "    t = X - M \n    P.N = t.7 \n    P.C = (X>=M) ? 1:0 \n    P.Z = (t==0) ? 1:0  \n \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xED, 0 , "SBC", "abs", 3 , 4 , cpu_6502_SBC_abs, "SBC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "**---**", " subtract with carry ", " A:=A-{adr} ", abs_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xEE, 1 , "INC", "abs", 3 , 6 , cpu_6502_INC_abs, "INC $ABCD", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", " increment ", " {adr}:={adr}+1 ", abs_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xEF, 1 , " *ISC ", "abs", 3 , 6 , cpu_6502_illegal, "", "absolute 16 bit address; data = mem[abs_high|abs_low]", "*----*-", "", "", abs_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xF0, 0 , "BEQ", "rel", 2 , 2 , cpu_6502_BEQ_rel, "BEQ $AB", "relativ; address is relativ with 8-bit signed offset to PC; adr=pc+offset", "-------", " branch on equal (zero set) ", " branch on Z=1 ", rel_adr_mode, "    if (P.Z == 1) GOTO (PC+M)  \n \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xF1, 0 , "SBC", "izy", 2 , 5 , cpu_6502_SBC_izy, "SBC ($A5),X", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", " subtract with carry ", " A:=A-{adr} ", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF2, 1 , " CRASH ", " ", 0 , 0 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF3, 1 , " *ISC ", "izy", 2 , 8 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF4, 1 , " *NOP ", "zpx", 2 , 4 , cpu_6502_illegal, "", "indirect Y-indexed zero page; ea = mem[zpadr|zpadr+1]+Y", "**---**", "", "", izy_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xF5, 0 , "SBC", "zpx", 2 , 4 , cpu_6502_SBC_zpx, "SBC $AB,X", "zero page with index register X; ea = zpadr+X", "**---**", " subtract with carry ", " A:=A-{adr} ", zpx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xF6, 0 , "INC", "zpx", 2 , 6 , cpu_6502_INC_zpx, "INC $AB,X", "zero page with index register X; ea = zpadr+X", "*----*-", " increment ", " {adr}:={adr}+1 ", zpx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xF7, 1 , " *ISC ", "zpx", 2 , 6 , cpu_6502_illegal, "", "zero page with index register X; ea = zpadr+X", "*----*-", "", "", zpx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xF8, 0 , "SED", "imp", 1 , 2 , cpu_6502_SED_imp, "SED ", "implizit; no additional info needed", "---1---", " set decimal ", " D:=1 ", imp_adr_mode, "    P.D = 1  \n \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xF9, 0 , "SBC", "aby", 3 , 4 , cpu_6502_SBC_aby, "SBC $ABCD,Y", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", " subtract with carry ", " A:=A-{adr} ", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFA, 1 , " *NOP ", "imp", 1 , 2 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFB, 1 , " *ISC ", "aby", 3 , 7 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFC, 1 , " *NOP ", "abx", 3 , 4 , cpu_6502_illegal, "", "absolute 16 bit address with index Y; ea = abs+Y", "**---**", "", "", aby_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xFD, 0 , "SBC", "abx", 3 , 4 , cpu_6502_SBC_abx, "SBC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "**---**", " subtract with carry ", " A:=A-{adr} ", abx_adr_mode, "    IF (P.D) \n      t = bcd(A) - bcd(M) - !P.C \n      P.V = (t>99 OR t<0) ? 1:0 \n    ELSE \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
  { 0xFE, 0 , "INC", "abx", 3 , 7 , cpu_6502_INC_abx, "INC $ABCD,X", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", " increment ", " {adr}:={adr}+1 ", abx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" },
{ 0xFF, 1 , " *ISC ", "abx", 3 , 7 , cpu_6502_illegal, "", "absolute indexed addressing -- absolute 16 bit address with index X; ea = abs+X", "*----*-", "", "", abx_adr_mode, "    M = (M + 1) & $FF \n    P.N = M.7 \n    P.Z = (M==0) ? 1:0  \n \n      t = A - M - !P.C \n      P.V = (t>127 OR t<-128) ? 1:0 \n    P.C = (t>=0) ? 1:0 \n    P.N = t.7 \n    P.Z = (t==0) ? 1:0 \n    A = t & 0xFF                     \n \n" }
};

int illegal[] = { 0x02, 0x03, 0x04, 0x07, 0x0B, 0x0C, 0x0F, 0x12, 0x13, 0x14, 0x17, 0x1A, 0x1B, 0x1C, 0x1F, 0x22, 0x23, 0x27, 0x2B, 0x2F, 0x32, 0x33, 0x34, 0x37, 0x3A, 0x3B, 0x3C, 0x3F, 0x42, 0x43, 0x44, 0x47, 0x4B, 0x4F, 0x52, 0x53, 0x54, 0x57, 0x5A, 0x5B, 0x5C, 0x5F, 0x62, 0x63, 0x64, 0x67, 0x6B, 0x6F, 0x72, 0x73, 0x74, 0x77, 0x7A, 0x7B, 0x7C, 0x7F, 0x80, 0x82, 0x83, 0x87, 0x89, 0x8B, 0x8F, 0x92, 0x93, 0x97, 0x9B, 0x9C, 0x9E, 0x9F, 0xA3, 0xA7, 0xAB, 0xAF, 0xB2, 0xB3, 0xB7, 0xBB, 0xBF, 0xC2, 0xC3, 0xC7, 0xCB, 0xCF, 0xD2, 0xD3, 0xD4, 0xD7, 0xDA, 0xDB, 0xDC, 0xDF, 0xE2, 0xE3, 0xE7, 0xEB, 0xEF, 0xF2, 0xF3, 0xF4, 0xF7, 0xFA, 0xFB, 0xFC, 0xFF };

